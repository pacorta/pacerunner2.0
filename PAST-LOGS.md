7/12/24

	‚Ä¢	üìç The app can now detect the device's current location and speed (in m/s).

7/13/24

	‚Ä¢	üì± The app detects the device's current location, but accuracy needs improvement (still buggy).
	‚Ä¢	Speed detection improvements:
		‚Ä¢	Detects speed in m/s, but I need to convert this to mph.
		‚Ä¢	Successfully runs on an iPhone.
	‚Ä¢	üí° Note for new devices: Go to Settings > Security & Privacy > General Tab, click "iproxy was blocked," then click Open Anyway to allow iproxy to run.
	‚Ä¢	üó∫Ô∏è Adds polyline points to mark the route taken during the session.

7/18/24

	‚Ä¢	The app now accesses speed information from the Map widget in the currentRun widget.
This was achieved using the Riverpod package for state management, which will be useful for displaying travel statistics elsewhere in the app.

7/19/24

	‚Ä¢	Speed is now displayed in mph instead of m/s.

8/7/24

	‚Ä¢	‚ú® New Features:
		‚Ä¢	The app calculates user's traveled distance from Start Running
		‚Ä¢	Post-run stats popup with total distance
	‚Ä¢	üîÑ Technical Updates:
		‚Ä¢	Transitioned to global state management
		‚Ä¢	Improved tracking control with state-driven approach

To-Do List ‚úÖ

	‚Ä¢	Create a summary page that includes the following:
	‚Ä¢	Total trip's polyline representation
	‚Ä¢	Average Pace
	‚Ä¢	Total Distance
	‚Ä¢	Time Elapsed
	‚Ä¢	Main Goal: Add a progress bar that compares the user's actual speed to an ideal speed:
	‚Ä¢	[‚Äî‚Äî‚Äî‚Äî‚Äî(Actual Pace: Too Slow)‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî(Best Pace)‚Äî‚Äî‚Äî‚Äî(Actual Pace: Too Fast)‚Äî‚Äî‚Äî‚Äî‚Äî]
	‚Ä¢	Remove the ability to go back to the home screen using the back arrow or sliding back, as this can cause data loss.

8/12/24

	‚Ä¢	‚öôÔ∏è Added unit selection (miles/kilometers) on Home Screen
	‚Ä¢	üìä Added pace calculations:
		‚Ä¢	Pace1 = hr/distance
		‚Ä¢	Pace2 = distance/hr
	‚Ä¢	üì∏ Discovered captureMapScreenshot() functionality

To-Do List

	‚Ä¢	Summary page to include:
	‚Ä¢	Total trip's polyline representation (possibly using captureMapScreenshot())
	‚Ä¢	Pace1
	‚Ä¢	Pace2
	‚Ä¢	Total Distance
	‚Ä¢	Time Elapsed
	‚Ä¢	Main Goal: Add a progress bar to compare the runner's speed to an ideal speed.

Resources:

	‚Ä¢	[Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
	‚Ä¢	[Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the [online documentation](https://docs.flutter.dev/), which offers tutorials, samples, guidance on mobile development, and a full API reference.


9/24/2024

	‚Ä¢	üéØ PaceBar Implementation:
	1.	Created a file for current_pace, which calculates the pace over a small time window.
	2.	Required the current pace in seconds to animate the pace bar accurately.
	‚Ä¢	Initially considered extracting the data from current_pace.dart using StateNotifier, but this was more complex than using StateProvider.
	‚Ä¢	Decided to use two distinct StateProvider files (current_pace and current_pace_in_seconds), simplifying the code and reducing the chance of bugs.
	3.	Made aesthetic changes to the PaceBar, including smoothing the animation. The animation now recreates itself with each pace change, starting from the current position and moving to the new one.
	4.	Implemented error handling: if the app receives an invalid pace (e.g., 0 or negative), the widget retains the last known valid position to prevent UI issues.
	5.	Created Normalized Pace to convert raw pace data (in seconds per mile) into a value between 0 and 1:
	‚Ä¢	Formula: 1 - (paceInSecondsPerMile - minPace) / (maxPace - minPace) normalizes the pace.
	‚Ä¢	The clamp(0.0, 1.0) call ensures the normalized pace stays within a valid range.
	‚Ä¢	Using the normalized value for rendering ensures a visually intuitive PaceBar, regardless of the specific pace range.
	‚Ä¢	Overall, this update works well. It was tested in real life and responded accurately to walking, jogging, and sprinting.
	‚Ä¢	Currently, the app sets the default optimal pace at 8 minutes per mile, but this can be customized. Eventually, the user will be prompted for their running goal, but this feature will be added after the data section is complete.



10/14/2024

	‚Ä¢	üîó Database Integration:
		‚Ä¢	Merged database with front end
		‚Ä¢	Added login screen and run history
	‚Ä¢	üêõ Known Bugs:
			‚Ä¢	When the user press 'stop running', the app keeps tracking the run even after sending the correct summary data to the running stats screen.To fix this I think I either need to:
				-Find the call that told the map to stop tracking (pretty sure it was called stopTracking) and find out how to call it with the button from currentRun
				-or double the power of whatever is making it stop eventually, because it does *eventually stop*. By this I mean attempting to activate that stop sooner.
			‚Ä¢	After having to upgrade to ios 15 becuse of dependency issues, I got the following messages in 'LocationPlugin' in the ios folder:
				- [CLLocationManager authorizationStatus] 		error---->>	'authorizationStatus' is deprecated: first deprecated in iOS 14.0
				- [CLLocationManager locationServicesEnabled]	error---->> 'This method can cause UI unresponsiveness if invoked on the main thread. Instead, consider waiting for the `-locationManagerDidChangeAuthorization:` callback and checking `authorizationStatus` first.'

12/16/24: UI + Security Update

	‚Ä¢	üõ†Ô∏è Fixed bugs:
			‚Ä¢	Distance unit conversion: Pace unit now updates correctly when switching distance units after run completion
			‚Ä¢	Run data persistence: Resolved issue where previous run data was displaying in current run screen
				‚Ä¢	Note: PaceBar still shows some residual data from previous runs
			‚Ä¢	API Key Security: Integration of dotenv to hide api keys and other sensitive data.
	
	‚Ä¢	üìù Lessons Learned:
			‚Ä¢	This project has taught me the importance of secure development practices and clean coding standards:
				‚Ä¢	I successfully implemented dotenv to manage sensitive information like API keys, ensuring that future development adheres to security best practices.
				‚Ä¢	I now proactively approach projects with a focus on secure and maintainable code.
	‚Ä¢	üîÑ In Progress:
			‚Ä¢	Adding vibration feedback for pace notifications

	‚Ä¢	‚úÖ To-Do:
			‚Ä¢	UI improvements for running screen, with focus on PaceBar enhancement for clarity and usability.
			‚Ä¢	Resolve pace tracking issues:
				‚Ä¢	Current pace and current pace in seconds not updating properly
				‚Ä¢	Consider consolidating pace states in providers for better PaceBar integration
			‚Ä¢	Take advantage of the variance calculations (difference between current pace and target pace) to create difficulty levels (easy, medium, hard).
			‚Ä¢	Add advanced visualizations, like post-run heatmaps to analyze pace trends.

	‚Ä¢	ü§ñ Android Configuration Setup:

			While the app currently focuses on iOS development, the Android configuration has been set up for future compatibility. The setup includes:

			‚Ä¢	Configured Gradle build system with Firebase integration
			‚Ä¢	Set up Google Services plugin in the following files:
				‚Ä¢	`android/settings.gradle`
				‚Ä¢	`android/app/build.gradle`
				‚Ä¢	`android/build.gradle`

			This configuration will simplify future Android deployment when needed, but is not actively used in the current development phase.

			Note: The app currently targets iOS development, and Android-specific features are not implemented yet.


7/9/2025: 

	‚Ä¢	Fixed bugs:

			‚Ä¢	Fixed state leakage after saving a user's run.
					- This was done by creating functions resetCurrentPaceProvider() and resetCurrentPaceInSecondsProvider().
					- These functions eliminate the memory leak and guarantee indempotent state initialization (term that I recently learned).
					- Lesson learned: In flutter/riverpod, everything in the state should live inside the provider graph. Global variables break the reactivity model and cause edge cases like these.
			
			‚Ä¢	Fixed state leakage after pressing 'stop' button.
					-This was done by re-positioning the tracking provider being false immediatly after pressing 'stop'; this stops the GPS and polyline at the same time and the stats are captured with final values. No more data leakage during the dialog.
			‚Ä¢	Fixed UI/UX issues during the pace selection part of the flow.
					-Added a limit to 999 units of distance
					-Shapes don't overflow anymore
			‚Ä¢	Standardized pace calculation intervals across providers: Resolved timing inconsistency where current_pace_provider.dart used 4-second intervals while current_pace_in_seconds_provider.dart used 3-second intervals. Both providers now use consistent 4-second windows for pace calculations, ensuring synchronized PaceBar animations and display metrics.
			

	‚Ä¢	Comments/Braindump/Vent: 

			Throughout this project I have been very insecure mainly because I always think this is not good enough for an MVP. But at least I have to launch it, then iterate on top of that. It might be embarrasing to launch a bad app, but at least that's better than never launching.


	‚Ä¢	MVP Development Checklist:

			‚Ä¢	What currently works:
				- GPS tracking and polyline ‚úì
				- Basic pace calculation ‚úì 
				- Visual PaceBar ‚úì
				- Firebase auth/storage ‚úì
				- Pace selection flow ‚úì

			‚Ä¢	To-Do (Must complete for MVP):
				1. Add GPS strength indicator with connection status (weak/strong/acquiring)
				2. Implement user-location-fetching pre-warming during pace selection flow
				3. Add pause/resume functionality with proper state management
				4. UI/UX improvements (next section)

			‚Ä¢	UI/UX Improvements:
				1. Implement play/pause/stop function.
				2. Add current goal header display ("1 mile in 8 minutes")
				3. Add a calculating-wheel for the current pace data. (If we gather this every 4 seconds, the wheel should fill every 4 seconds, then reset). This adds transparency with the user.
					3.1. Add a grace period to start calculating current pace (don't calculate if the user is not yet moving)
				4. Restructure current_run.dart layout to match professional design
				5. Integrate map view seamlessly with new layout

			‚Ä¢	Minimum improvements for MVP:
				- GPS pre-warming to improve UX significantly.
				- "Calculating pace" UI to avoid user confusion.
				- Grace period of time or distance


	‚Ä¢	Ideas:

			‚Ä¢	Have several run-modes in the app:
				‚Ä¢	Make this whole concept of "current pace" into one of the ways to run with this app, call it "Time-Objective Run" or something.
				‚Ä¢	I think the main/best run will be when you set the pace you want to be running at, and you have two buttons (higher/lower). If you set it to 10mph and you are running at a pace of 8, then you are in the red zone because it's too fast. If you feel well in the pace of 8mph, then you can easily adjust your new green zone. This will just be another one in the many run-modes this app will have.
				‚Ä¢	Add another fun mode like "dog-chase" or "zombie-chase" where you have to outrun them. They could switch the pace at random times and you will be notified to hurry or they catch you.

			‚Ä¢	Add fun features or facts about the running stats:
				‚Ä¢	"Based on your running stats, you could outrun this animal" (reference: https://www.runguides.com/event/21604/find-your-strength-5k)
				‚Ä¢	"Only x% of the world is able to run a distance this long!"


7/21/2025:

			‚Ä¢	Added real-time GPS strength indicator with color-coded status (strong/good/weak/acquiring) using location accuracy data from map.dart.

			‚Ä¢	To-Do (Must complete for MVP)
				1. [‚àö] 	Add GPS strength indicator with connection status (acquiring/weak/good/strong) 
				2. 		Implement user-location-fetching pre-warming during pace selection flow
				3. 		Add pause/resume functionality with proper state management
				4. 		UI/UX improvements

7/22/2025:

		‚Ä¢	GPS Pre-warming Implementation: Solved GPS delayed start during the start of the run by, instead, implementing location fetching during pace selection process.

				‚Ä¢ Created LocationService to centralize all GPS operations across the app
				‚Ä¢ Moved GPS initialization from CurrentRun screen to PaceSelection screen  
				‚Ä¢ Eliminated 3-10 second GPS delay when users press "Start Running"
				‚Ä¢ Made it modular for (potential) alternate run modes in the future.

			‚Ä¢	How this was achieved:
				‚Ä¢ LocationService.dart: Static class using StreamController.broadcast() for multiple widget listeners
				‚Ä¢ PaceSelection widget: GPS starts warming in initState(), continues during user configuration
				‚Ä¢ Map widget: Converted from GPS owner to GPS consumer, listens to existing LocationService stream
				‚Ä¢ Smart cleanup: Only stops GPS if user exits without completing run setup

			‚Ä¢	Technical challenges solved:
				‚Ä¢ Riverpod lifecycle issue: "Cannot use ref after widget disposed" error when stopping GPS
				‚Ä¢ Solution: Added try-catch blocks around provider updates in LocationService
				‚Ä¢ Stream management: Replaced direct GPS subscriptions with broadcast stream architecture

			‚Ä¢	Lessons learned:
				‚Ä¢ Static services holding widget references need defensive programming (try-catch)
				‚Ä¢ StreamController.broadcast() enables multiple listeners to same GPS stream
				‚Ä¢ GPS pre-warming improves UX a lot.
				‚Ä¢ Singleton pattern with static methods provides clean service layer without constructor overhead

			‚Ä¢	Result: Users now experience instant GPS lock when starting runs, significantly improved UX flow.

		‚Ä¢	To-Do (Must complete for MVP):
			1. [‚àö] 	Add GPS strength indicator with connection status (acquiring/weak/good/strong) 
			2. [‚àö] 	Implement user-location-fetching pre-warming during pace selection flow
			3. 		Add pause/resume functionality with proper state management
			4. 		UI/UX improvements


7/23/2025:

	‚Ä¢	Pause/Resume/Stop Implementation: Added complete state management for running sessions with proper timer control and correct data handling.

		‚Ä¢ Created RunState enum (notStarted, running, paused, finished) for clear session state management
		‚Ä¢ Implemented PausableTimer class to handle timer that keeps accumulated time across pause/resume cycles
		‚Ä¢ Updated CurrentRun screen to use state-driven approach instead of manual Stopwatch/Timer management
		‚Ä¢ Dynamic UI buttons based on run state: PAUSE (when running) or RESUME/FINISH (when paused)

		How this was achieved:
		‚Ä¢ RunStateProvider: Central state management for overall run status with derived providers for UI logic
		‚Ä¢ PausableTimerProvider: Custom timer that tracks accumulated time and session start time separately
		‚Ä¢ Map widget integration: Distance only accumulates during RunState.running, preventing wrong data during pause
		‚Ä¢ Location tracking continuity: GPS updates continue during pause to prevent distance jumps on resume

		Technical challenges solved:
		‚Ä¢ Race condition in _endRun(): Fixed order of operations to capture final data before resetting timer state
		‚Ä¢ Distance accumulation during pause: Added conditional logic to only track distance when actively running
		‚Ä¢ Distance jumping on resume: Maintained continuous location history even during pause state
		‚Ä¢ Timer state consistency: Replaced multiple elapsed time providers with one unified system

		Lessons learned:
		‚Ä¢ Order of operations is very important when capturing final state before cleanup
		‚Ä¢ Separating data collection (GPS) from data processing (distance calculation) prevents edge cases
		‚Ä¢ State-driven UI design scales better than manual button state management
		‚Ä¢ Having one place for timer data prevents provider synchronization issues

		Result: Users can now pause runs without losing data accuracy, with proper time tracking and distance calculations.

	‚Ä¢	To-Do (Must complete for MVP):
			1. [‚àö] 	Add GPS strength indicator with connection status (acquiring/weak/good/strong) 
			2. [‚àö] 	Implement user-location-fetching pre-warming during pace selection flow
			3. [‚àö]	Add pause/resume/stop functionality with proper state management
			4.		'Calculating wheel' for current pace
			5.		Grace period in the beginning for pace calculation
			6. 		UI/UX improvements


7/25/27:
	‚Ä¢	Performed small UI/UX Changes


7/26/27:

	‚Ä¢	No changes done, but I've realized a couple of things during the past few days:
		‚Ä¢	I talked to ChatGPT about my pre-warming approach because I was unsure if that's the industry-standard; I came to the realization that this is just me over-engineering everything. Apparently, apps like Strava or Nike Run Club just add a "loading" sign. This is way more effective and error-proof.
		‚Ä¢	For months I've been thinking about how the current pace automatically discards the rest of the run. I think this was another case of me over-engineering (or overthinking). Obviosuly the industry standard 'average pace' takes the whole run into account + the most recent changes.
			‚Ä¢	I think I am going to use the average to show the answer to the question "given everything I've ran so far, how long am I going to take to finish my goal if I keep running the same?". This is a question I always ask myself mid-run and at least this tool would be useful to me.
			‚Ä¢	Another run-mode I am thinking of is to have a speedometer. If the user wants to keep running at a certain pace, the app will notify them if they're off-track. There should be an easy way during the run to change this speed. I think of this like a treadmill but for outside (with buttons like ‚¨Ü, ‚¨á).

	‚Ä¢	Updated To-Do List (Based on recent changes):
		‚Ä¢	1.	Add play button during the current-run screen
		‚Ä¢	2.	Move the logic to start user-location-fetching only in the current-run screen + add a "fetching location..." notification with a loading spinner.
		‚Ä¢	3.	UI/UX improvements
		‚Ä¢	4.	Outdoors Testing
		‚Ä¢	5.	Launch?


7/28/25:

	‚Ä¢	GPS Flow Redesign: Changed how GPS works to be more like other running apps (Strava, Nike Run Club) with a simple loading screen instead of trying to start GPS in the background.

		‚Ä¢ Moved GPS setup from pace selection to the running screen where it shows "Getting GPS signal..."
		‚Ä¢ Added proper run states: looking for GPS, ready to start, running, paused, and finished
		‚Ä¢ Shows clear loading screen while GPS connects instead of hiding it in the background
		‚Ä¢ Added 30-second timeout so users can start even if GPS is slow

		Technical changes:
		‚Ä¢ Fixed run_state_provider.dart to handle the new flow properly
		‚Ä¢ Rebuilt current_run.dart to show different screens based on what the app is doing
		‚Ä¢ Cleaned up pace_selection.dart by removing GPS code that was causing problems
		‚Ä¢ Had to move GPS listener to build() method because of Flutter/Riverpod rules

		Bug fixes:
		‚Ä¢ Fixed crashes when widgets close while GPS is still updating
		‚Ä¢ Made LocationService always stop GPS properly when leaving the running screen
		‚Ä¢ Added safety checks so the app doesn't crash when switching between screens
		‚Ä¢ Solved timing issues between GPS updates and app navigation

		UI improvements:
		‚Ä¢ Clear "Getting GPS..." screen so users know what's happening
		‚Ä¢ Shows helpful hints if GPS takes longer than 15 seconds
		‚Ä¢ Only shows running features when GPS is actually ready
		‚Ä¢ Much clearer when the app is ready vs still setting up

		Result: GPS now works like other running apps with clear loading states and no more random crashes.

		Extras:
		‚Ä¢ Removed unnecessary snack bar notifications during the pace selection process.
		‚Ä¢ Allowed for more precise polyline marking by only allowing its mark to appear with the trigger of the start button (no more polyline marking when off-duty). Achieved this by adding an if statement with the run states.
		‚Ä¢ Small UI changes


	‚Ä¢	Updated To-Do List for MVP:
		‚Ä¢	1.	[‚àö] Move GPS logic to current-run screen with loading state
		‚Ä¢	2.		Organize the run modes ('predictive finish' and 'steady pace')
		‚Ä¢	3.		Enable captureMapScreenshot() to show map summary at the end of the run. Also show the date/time. Maybe pace splits?
		‚Ä¢	4.		UI/UX improvements (colors, fonts, layouts)
		‚Ä¢	5.		Test the app outside
		‚Ä¢	6.		Get ready to launch


8/2/2025:

	‚Ä¢	Added complete polyline route image at the end of the run and made some UI changes.

	‚Ä¢	Introduced a screenshot of the route at the end of the run. It's a fun feature and I want to expand on it more by saving this screenshot to the firebase data; but I think I will save this for V2, not for the MVP. Used 
	‚Ä¢	Used 
	‚Ä¢	Added the date/time of when the run was started to the run data.
	‚Ä¢	Played around with the UI in the Activities screen. I think I'm finding the right colors for this app.

	‚Ä¢	Major UI/UX Overhaul:
		‚Ä¢	Added new app logo to home and login screens
		‚Ä¢	Redesigned Activities screen with modern card layout, placeholder action buttons for later updates (info/share), and bottom navigation
		‚Ä¢	Improved Current Run screen with readable pace header, better stats layout, and conditional PaceBar display
		‚Ä¢	Improved Pace Selection with better button layout and legible goal summaries

	‚Ä¢	Technical Improvements:
		‚Ä¢	Added new Riverpod providers for map controller, locations, and readable pace state management
		‚Ä¢	Improved error handling and cleanup logic across widgets
		‚Ä¢	Refactored state management for better modularity and testability

	‚Ä¢ 	In the next updates:
		‚Ä¢ I am going to improve the UI of the summary dialog at the end of the run. I need to keep in mind that, in a later update, I want to copy this into the user's clipboard automatically. The purpose is for them to share it on their social media accounts.
		‚Ä¢ I am planning to stabilize the average pace. I'm lookin into how popular apps do this. The goal is to not have jumpy data.
		‚Ä¢ I will then start with run mode 1 ("Goal focused run").
		‚Ä¢ Then, run mode 2 ("Stable pace mode")
		‚Ä¢ After that, run mode 3 ("Classic Run")

	‚Ä¢ Each of these tasks will come with their own struggles, but I think after finishing these properly I'm ready to launch the MVP.

	No real issues were encountered here.


8/3/2025:

	Run Summary Dialog Redesign: Completely rebuilt the run completion dialog with a modern card-style design and added image export functionality for social media sharing.

		‚Ä¢ Created RunSummaryCard widget as a reusable component with dark semi-transparent background, compact map display, vertically stacked metrics, and integrated logo
		‚Ä¢ Implemented PNG export to clipboard using RepaintBoundary for widget-to-image conversion
		‚Ä¢ Redesigned button layout with three clear actions: Save run (preserves existing functionality), Share run (copies image to clipboard), and Discard run (with confirmation dialog)
		‚Ä¢ Added high-quality image generation with 2x pixel ratio and base64 encoding for universal app compatibility

	‚Ä¢ How this was achieved:
		‚Ä¢ RepaintBoundary wrapper around exportable content to separate interactive UI from image content
		‚Ä¢ Flutter's built-in rendering pipeline: Widget Tree ‚Üí Render Tree ‚Üí PNG conversion using dart:ui toImage() method
		‚Ä¢ GlobalKey system to access render objects for image capture without external dependencies
		‚Ä¢ Base64 encoding with data URI format for cross-platform clipboard compatibility

	‚Ä¢ Technical challenges solved:
		‚Ä¢ iOS simulator limitation: Clipboard shows base64 text instead of image (expected behavior, works properly on real devices)
		‚Ä¢ State management: Proper cleanup and provider reset logic maintained across all dialog actions
		‚Ä¢ Image quality: Implemented pixelRatio settings for Retina-quality exports
		Error handling: Added comprehensive try-catch blocks with user feedback via SnackBar notifications

	‚Ä¢ Lessons learned:
		‚Ä¢ Flutter's widget architecture makes complex tasks like image export very simple with the right approach
		‚Ä¢ RepaintBoundary design pattern enables clean separation between exportable content and interactive elements
		‚Ä¢ Built-in APIs (dart:ui, dart:convert, flutter/services) provide strong solutions without external dependencies
		‚Ä¢ Widget-to-image conversion leverages GPU acceleration for high-performance rendering

	Result: Users can now share professional-looking run summaries directly from the app to any platform, with the dialog matching modern design standards and maintaining all existing functionality.


8/4/2025:

	UI changes:
		‚Ä¢ During the timing selection, I switched the slider for a numeric keyboard with suggestions (30 mins, 1 hr, etc.). Previous map I made for realistic timings work better with this approach.
		‚Ä¢ Consitent colored cards
		‚Ä¢ Switched the running-man-marker in the pacebar for a dog, given that the new logo has a dog. I added a conditional statement; if the run is paused, the dog will stay still wagging his tail.
		‚Ä¢ Removed motivational message display from pace bar (commented out for future haptic/sound implementation)
		‚Ä¢ Other minor changes
	
	Later on today I will start working on the stable average pace provider(task #1), this will help me predict the end time of the run (task #2), based on the run so far.


# Pacebud Progress: 8/5/2025

## Stable Pace & Prediction System

Implemented a stable average pace provider to eliminate jumpy data and added accurate finish time predictions for goal-focused runners.

### Stable Average Pace Implementation

- Created time throttling (2-second intervals) and data smoothing (3-value moving average) to replace the jumpy average pace display. Similar to how Strava handles pace calculations for consistent UX.
- Projected Finish Time System: Added real-time predictions showing "At your current pace, you'll finish in X time" based on stable pace calculations rather than instant pace data (previous 'current pace' approach).
- Critical Unit Conversion Fix: Resolved incorrect pace calculations when using kilometers that was causing wrong predictions (showing "fast" when actually running slow). The issue was in pace selection where km distances were being incorrectly normalized to miles before calculation.

---

## How this was achieved

- Two-strategy approach: Time throttling prevents constant updates, data smoothing uses moving average of recent values.
- Created new providers for target distance/time that integrate with existing custom pace system.
- Built compact prediction display widget to fit existing UI without overflow.
- Connected stable pace provider to prediction system using string-to-seconds parsing.

---

## Conclusion

This marks the end of my first iteration of the "current pace" approach. At the beginning of the project, I thought showing the user's pace over the last few seconds (4s window) would be the best way to alert them if they were going too slow or fast. But after running again consistently, I realized that what runners truly care about is simpler: 

> ‚ÄúIf I keep going at this pace, when will I finish my goal distance?‚Äù

That question is fully answered by the **stable average pace**, not the jumpy pace from the last few seconds. This new approach solves two essential needs:
1. It reflects how long the runner has been running, including adjustments from recent speed changes.
2. It enables an accurate **projected finish time**, which is far more actionable and goal-oriented than short-term pace feedback.

Ironically, once I returned to running regularly, the solution became clear. I had been overcomplicating things. What runners need is clarity, not noise. And to design for that, I had to take a step back and think like a runner, not just a developer.

---

## Result

The app now provides:

- **Stable, smoothed average pace calculations** using time throttling and moving averages.
- **Accurate, real-time finish time predictions** based on consistent pace.
- Full support for **both kilometers and miles**, with corrected unit conversion logic.

This makes the running experience more reliable and intuitive for goal-driven users.

---

## Next Steps

- Modify the pacebar so it reflects the gap between the **goal pace** (green zone) and the **projected finish**.
- Add run mode selection system and prepare framework for future running modes.